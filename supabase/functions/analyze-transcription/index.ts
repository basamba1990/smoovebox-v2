// supabase/functions/analyze-transcription/index.js
import { createClient } from 'npm:@supabase/supabase-js@2.39.3'
import OpenAI from 'npm:openai@4.28.0'

// ‚úÖ Cache en m√©moire pour optimiser les performances
const analysisCache = new Map();
const CACHE_TTL = 30 * 60 * 1000;

// ‚úÖ Syst√®me de retry avec backoff exponentiel
const retryWithBackoff = async (fn, maxRetries = 3, baseDelay = 1000) => {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries - 1) throw error;
      const delay = baseDelay * Math.pow(2, attempt);
      await new Promise(resolve => setTimeout(resolve, delay + Math.random() * 1000));
      console.log(`üîÑ Retry attempt ${attempt + 1} after ${delay}ms`);
    }
  }
};

const VIDEO_STATUS = {
  UPLOADED: 'uploaded',
  PROCESSING: 'processing',
  TRANSCRIBED: 'transcribed',
  ANALYZING: 'analyzing',
  ANALYZED: 'analyzed',
  PUBLISHED: 'published',
  FAILED: 'failed'
};

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS'
};

// ‚úÖ CORRECTION : Gestion robuste du parsing JSON
const parseRequestBody = async (req) => {
  try {
    const contentType = req.headers.get('content-type') || '';
    
    if (!contentType.includes('application/json')) {
      throw new Error('Content-Type must be application/json');
    }

    const requestBody = await req.json();
    
    if (!requestBody || typeof requestBody !== 'object') {
      throw new Error('Request body must be a valid JSON object');
    }

    return requestBody;
  } catch (error) {
    console.error('‚ùå Erreur parsing request body:', error);
    throw new Error(`Invalid JSON body: ${error.message}`);
  }
};

// ‚úÖ PROMPTS MULTILINGUES AM√âLIOR√âS avec analyse de tonalit√© int√©gr√©e
const ANALYSIS_PROMPTS = {
  fr: `Analyse le texte de transcription suivant et fournis une analyse d√©taill√©e en fran√ßais au format JSON avec cette structure :

{
  "summary": "R√©sum√© concis du contenu (150-200 mots)",
  "key_topics": ["liste", "de", "th√®mes", "principaux"],
  "sentiment": "positif/n√©gatif/neutre",
  "sentiment_score": 0.85,
  "communication_advice": [
    "Conseil 1 pour am√©liorer la communication",
    "Conseil 2 pour renforcer l'impact"
  ],
  "tone_analysis": {
    "emotion": "√©motion dominante (joyeux, triste, en col√®re, neutre, enthousiaste, calme, √©nergique, stress√©, confiant)",
    "pace": "d√©bit vocal (lent, mod√©r√©, rapide)",
    "clarity": "clart√© vocale (faible, moyenne, bonne, excellente)",
    "energy": "niveau d'√©nergie (faible, moyen, √©lev√©)",
    "confidence_level": 0.75,
    "cultural_insights": ["insight culturel 1", "insight culturel 2"],
    "tone_suggestions": [
      "Suggestion 1 pour am√©liorer le ton",
      "Suggestion 2 pour ajuster le d√©bit",
      "Suggestion 3 pour renforcer l'impact"
    ]
  },
  "structure_analysis": {
    "introduction": "qualit√© introduction",
    "development": "qualit√© d√©veloppement", 
    "conclusion": "qualit√© conclusion",
    "overall_structure": "√©valuation structure globale"
  },
  "target_audience": ["audience cible 1", "audience cible 2"],
  "visual_suggestions": ["suggestion visuelle 1", "suggestion visuelle 2"]
}

IMPORTANT : Pour l'analyse de tonalit√©, consid√®re :
- Le d√©bit des phrases (longues = lent, courtes = rapide)
- La diversit√© du vocabulaire (riche = √©nergique, limit√© = calme)
- La ponctuation (nombre d'exclamations, points, etc.)
- La complexit√© des phrases
- Les mots √©motionnels utilis√©s

Texte √† analyser :
{text}

IMPORTANT : R√©ponds UNIQUEMENT en JSON valide, sans texte suppl√©mentaire.`,

  ar: `ÿ≠ŸÑŸÑ ŸÜÿµ ÿßŸÑŸÜÿ≥ÿÆ ÿßŸÑÿ™ÿßŸÑŸä ŸàŸÇÿØŸÖ ÿ™ÿ≠ŸÑŸäŸÑÿßŸã ŸÖŸÅÿµŸÑÿßŸã ÿ®ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ÿ®ÿ™ŸÜÿ≥ŸäŸÇ JSON ŸÖÿπ Ÿáÿ∞Ÿá ÿßŸÑÿ®ŸÜŸäÿ©:

{
  "summary": "ŸÖŸÑÿÆÿµ ŸÖŸàÿ¨ÿ≤ ŸÑŸÑŸÖÿ≠ÿ™ŸàŸâ (150-200 ŸÉŸÑŸÖÿ©)",
  "key_topics": ["ŸÇÿßÿ¶ŸÖÿ©", "ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ", "ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©"],
  "sentiment": "ÿ•Ÿäÿ¨ÿßÿ®Ÿä/ÿ≥ŸÑÿ®Ÿä/ŸÖÿ≠ÿßŸäÿØ", 
  "sentiment_score": 0.85,
  "communication_advice": [
    "ŸÜÿµŸäÿ≠ÿ© 1 ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ™ŸàÿßÿµŸÑ",
    "ŸÜÿµŸäÿ≠ÿ© 2 ŸÑÿ™ÿπÿ≤Ÿäÿ≤ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±"
  ],
  "tone_analysis": {
    "emotion": "ÿßŸÑÿπÿßÿ∑ŸÅÿ© ÿßŸÑŸÖÿ≥Ÿäÿ∑ÿ±ÿ© (ŸÅÿ±ÿ≠, ÿ≠ÿ≤ŸÜ, ÿ∫ÿ∂ÿ®, ŸÖÿ≠ÿßŸäÿØ, ŸÖÿ™ÿ≠ŸÖÿ≥, ŸáÿßÿØÿ¶, ŸÜÿ¥Ÿäÿ∑, ŸÖÿ™Ÿàÿ™ÿ±, Ÿàÿßÿ´ŸÇ)",
    "pace": "ÿ≥ÿ±ÿπÿ© ÿßŸÑŸÉŸÑÿßŸÖ (ÿ®ÿ∑Ÿäÿ°, ŸÖÿπÿ™ÿØŸÑ, ÿ≥ÿ±Ÿäÿπ)",
    "clarity": "Ÿàÿ∂Ÿàÿ≠ ÿßŸÑÿµŸàÿ™ (ÿ∂ÿπŸäŸÅ, ŸÖÿ™Ÿàÿ≥ÿ∑, ÿ¨ŸäÿØ, ŸÖŸÖÿ™ÿßÿ≤)",
    "energy": "ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ∑ÿßŸÇÿ© (ÿ∂ÿπŸäŸÅ, ŸÖÿ™Ÿàÿ≥ÿ∑, ŸÖÿ±ÿ™ŸÅÿπ)",
    "confidence_level": 0.75,
    "cultural_insights": ["ÿ±ÿ§Ÿäÿ© ÿ´ŸÇÿßŸÅŸäÿ© 1", "ÿ±ÿ§Ÿäÿ© ÿ´ŸÇÿßŸÅŸäÿ© 2"],
    "tone_suggestions": [
      "ÿßŸÇÿ™ÿ±ÿßÿ≠ 1 ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑŸÜÿ®ÿ±ÿ©",
      "ÿßŸÇÿ™ÿ±ÿßÿ≠ 2 ŸÑÿ∂ÿ®ÿ∑ ÿßŸÑÿ≥ÿ±ÿπÿ©",
      "ÿßŸÇÿ™ÿ±ÿßÿ≠ 3 ŸÑÿ™ÿπÿ≤Ÿäÿ≤ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±"
    ]
  },
  "structure_analysis": {
    "introduction": "ÿ¨ŸàÿØÿ© ÿßŸÑŸÖŸÇÿØŸÖÿ©",
    "development": "ÿ¨ŸàÿØÿ© ÿßŸÑÿπÿ±ÿ∂",
    "conclusion": "ÿ¨ŸàÿØÿ© ÿßŸÑÿÆÿßÿ™ŸÖÿ©",
    "overall_structure": "ÿ™ŸÇŸäŸäŸÖ ÿßŸÑŸáŸäŸÉŸÑ ÿßŸÑÿπÿßŸÖ"
  },
  "target_audience": ["ÿßŸÑÿ¨ŸÖŸáŸàÿ± ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ 1", "ÿßŸÑÿ¨ŸÖŸáŸàÿ± ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ 2"],
  "visual_suggestions": ["ÿßŸÇÿ™ÿ±ÿßÿ≠ ÿ®ÿµÿ±Ÿä 1", "ÿßŸÇÿ™ÿ±ÿßÿ≠ ÿ®ÿµÿ±Ÿä 2"]
}

ŸáÿßŸÖ: ŸÑÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÜÿ®ÿ±ÿ©ÿå ÿ∂ÿπ ŸÅŸä ÿßŸÑÿßÿπÿ™ÿ®ÿßÿ±:
- ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ¨ŸÖŸÑ (ÿ∑ŸàŸäŸÑÿ© = ÿ®ÿ∑Ÿäÿ¶ÿ©ÿå ŸÇÿµŸäÿ±ÿ© = ÿ≥ÿ±Ÿäÿπÿ©)
- ÿ™ŸÜŸàÿπ ÿßŸÑŸÖŸÅÿ±ÿØÿßÿ™ (ÿ∫ŸÜŸäÿ© = ŸÜÿ¥Ÿäÿ∑ÿ©ÿå ŸÖÿ≠ÿØŸàÿØÿ© = ŸáÿßÿØÿ¶ÿ©)
- ÿπŸÑÿßŸÖÿßÿ™ ÿßŸÑÿ™ÿ±ŸÇŸäŸÖ (ÿπÿØÿØ ÿπŸÑÿßŸÖÿßÿ™ ÿßŸÑÿ™ÿπÿ¨ÿ®ÿå ÿßŸÑŸÜŸÇÿßÿ∑ÿå ÿ•ŸÑÿÆ)
- ÿ™ÿπŸÇŸäÿØ ÿßŸÑÿ¨ŸÖŸÑ
- ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿπÿßÿ∑ŸÅŸäÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿ©

ÿßŸÑŸÜÿµ ÿßŸÑŸÖÿ±ÿßÿØ ÿ™ÿ≠ŸÑŸäŸÑŸá:
{text}

ŸáÿßŸÖ: ÿ£ÿ¨ÿ® ŸÅŸÇÿ∑ ÿ®ÿ™ŸÜÿ≥ŸäŸÇ JSON ÿµÿßŸÑÿ≠ÿå ÿ®ÿØŸàŸÜ ŸÜÿµ ÿ•ÿ∂ÿßŸÅŸä.`,

  en: `Analyze the following transcription text and provide a detailed analysis in English in JSON format with this structure:

{
  "summary": "Concise content summary (150-200 words)", 
  "key_topics": ["list", "of", "main", "themes"],
  "sentiment": "positive/negative/neutral",
  "sentiment_score": 0.85,
  "communication_advice": [
    "Advice 1 to improve communication",
    "Advice 2 to strengthen impact"  
  ],
  "tone_analysis": {
    "emotion": "dominant emotion (joyful, sad, angry, neutral, enthusiastic, calm, energetic, stressed, confident)",
    "pace": "speaking pace (slow, moderate, fast)",
    "clarity": "vocal clarity (poor, average, good, excellent)",
    "energy": "energy level (low, medium, high)",
    "confidence_level": 0.75,
    "cultural_insights": ["cultural insight 1", "cultural insight 2"],
    "tone_suggestions": [
      "Suggestion 1 to improve tone",
      "Suggestion 2 to adjust pace", 
      "Suggestion 3 to strengthen impact"
    ]
  },
  "structure_analysis": {
    "introduction": "introduction quality",
    "development": "development quality",
    "conclusion": "conclusion quality", 
    "overall_structure": "overall structure assessment"
  },
  "target_audience": ["target audience 1", "target audience 2"],
  "visual_suggestions": ["visual suggestion 1", "visual suggestion 2"]
}

IMPORTANT: For tone analysis, consider:
- Sentence pace (long = slow, short = fast)
- Vocabulary diversity (rich = energetic, limited = calm)
- Punctuation (number of exclamations, periods, etc.)
- Sentence complexity
- Emotional words used

Text to analyze:
{text}

IMPORTANT: Respond ONLY in valid JSON, without additional text.`
};

const SYSTEM_MESSAGES = {
  fr: "Tu es un expert en analyse de communication, d'expression orale et d'analyse de tonalit√© vocale. Tu analyses des transcriptions vid√©o pour fournir des insights pr√©cieux sur le contenu, le ton, la structure et l'impact. Tes analyses sont objectives, constructives et pr√©cises.",
  ar: "ÿ£ŸÜÿ™ ÿÆÿ®Ÿäÿ± ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸàÿßŸÑÿ™ÿπÿ®Ÿäÿ± ÿßŸÑÿ¥ŸÅŸáŸä Ÿàÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÜÿ®ÿ±ÿ© ÿßŸÑÿµŸàÿ™Ÿäÿ©. ÿ™ŸÇŸàŸÖ ÿ®ÿ™ÿ≠ŸÑŸäŸÑ ŸÜÿµŸàÿµ ÿßŸÑŸÅŸäÿØŸäŸà ŸÑÿ™ŸÇÿØŸäŸÖ ÿ±ÿ§Ÿâ ŸÇŸäŸÖÿ© ÿ≠ŸàŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸàÿßŸÑŸÜÿ®ÿ±ÿ© ŸàÿßŸÑŸáŸäŸÉŸÑ ŸàÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±. ÿ™ÿ≠ŸÑŸäŸÑÿßÿ™ŸÉ ŸÖŸàÿ∂ŸàÿπŸäÿ© Ÿàÿ®ŸÜÿßÿ°ÿ© ŸàÿØŸÇŸäŸÇÿ©.",
  en: "You are an expert in communication, oral expression and vocal tone analysis. You analyze video transcripts to provide valuable insights about content, tone, structure and impact. Your analyses are objective, constructive and accurate."
};

const SUPPORTED_ANALYSIS_LANGUAGES = {
  'fr': 'French',
  'ar': 'Arabic', 
  'en': 'English',
  'es': 'Spanish',
  'de': 'German',
  'it': 'Italian',
  'pt': 'Portuguese'
};

const LANGUAGE_DETECTION_KEYWORDS = {
  'fr': ['le', 'la', 'les', 'de', 'des', 'du', 'et', 'est', 'dans', 'pour', 'vous', 'nous', 'je', 'tu'],
  'ar': ['ÿßŸÑ', 'ŸÅŸä', 'ŸÖŸÜ', 'ÿπŸÑŸâ', 'ÿ•ŸÑŸâ', 'ÿ£ŸÜ', 'Ÿáÿ∞ÿß', 'Ÿáÿ∞Ÿá', 'ŸÉÿßŸÜ', 'ŸÖÿß', 'ŸÑÿß', 'ÿ•ŸÜ', 'ÿ£ŸÜ', 'ŸÖÿπ'],
  'en': ['the', 'and', 'is', 'in', 'to', 'of', 'a', 'that', 'it', 'with', 'for', 'on', 'as', 'was'],
  'es': ['el', 'la', 'de', 'que', 'y', 'en', 'un', 'es', 'se', 'no', 'los', 'las', 'del', 'al'],
  'de': ['der', 'die', 'das', 'und', 'in', 'den', 'von', 'zu', 'ist', 'sich', 'mit', 'dem', 'den', 'des'],
  'it': ['il', 'la', 'di', 'e', 'in', 'che', 'non', 'per', 'un', 'una', 'sono', 'con', 'del', 'al'],
  'pt': ['o', 'a', 'de', 'e', 'do', 'da', 'em', 'um', 'para', 'com', 'n√£o', 'se', 'os', 'as']
};

Deno.serve(async (req) => {
  console.log("üîç Fonction analyze-transcription (avec analyse de tonalit√© int√©gr√©e) appel√©e");

  // ‚úÖ GESTION CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { 
      headers: {
        ...corsHeaders,
        'Access-Control-Max-Age': '86400',
      }
    });
  }

  let videoId = null;

  try {
    // ‚úÖ CORRECTION : Utiliser la nouvelle fonction de parsing robuste
    const requestBody = await parseRequestBody(req);
    
    const { videoId: vidId, transcriptionText, userId, transcriptionLanguage } = requestBody;
    videoId = vidId;

    // ‚úÖ VALIDATION STRICTE DES PARAM√àTRES
    if (!videoId || typeof videoId !== 'string' || videoId.length > 100) {
      return new Response(
        JSON.stringify({ 
          error: 'Param√®tre videoId invalide ou manquant'
        }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // ‚úÖ AJOUT : Validation des param√®tres re√ßus
    console.log("üîç Validation des param√®tres re√ßus:", {
      videoId: videoId,
      transcriptionTextLength: transcriptionText?.length,
      userId: userId,
      transcriptionLanguage: transcriptionLanguage
    });

    // ‚úÖ VALIDATION RENFORC√âE DU TEXTE
    if (!transcriptionText || transcriptionText.trim().length === 0) {
      throw new Error('Le texte de transcription est vide ou manquant');
    }

    if (transcriptionText.trim().length < 10) {
      throw new Error('Le texte de transcription est trop court pour l\'analyse (minimum 10 caract√®res)');
    }

    // ‚úÖ NETTOYAGE DU TEXTE
    const cleanTranscriptionText = transcriptionText.trim().substring(0, 10000); // Limite de s√©curit√©
    console.log(`üìù Texte nettoy√©: ${cleanTranscriptionText.length} caract√®res`);

    // ‚úÖ R√âCUP√âRATION S√âCURIS√âE DES CL√âS D'ENVIRONNEMENT
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    const openaiApiKey = Deno.env.get('OPENAI_API_KEY');

    if (!supabaseUrl || !supabaseServiceKey || !openaiApiKey) {
      console.error('‚ùå Configuration manquante:', {
        hasSupabaseUrl: !!supabaseUrl,
        hasServiceKey: !!supabaseServiceKey,
        hasOpenAIKey: !!openaiApiKey
      });
      throw new Error('Configuration serveur incompl√®te');
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    const openai = new OpenAI({ apiKey: openaiApiKey });

    // ‚úÖ V√âRIFICATION QUE LA VID√âO EXISTE
    console.log(`üîç Recherche vid√©o s√©curis√©e: ${videoId}`);
    const { data: video, error: videoError } = await supabase
      .from('videos')
      .select('*')
      .eq('id', videoId)
      .single();

    if (videoError || !video) {
      console.error("‚ùå Vid√©o non trouv√©e:", videoError);
      throw new Error('Vid√©o non trouv√©e ou acc√®s non autoris√©');
    }

    // ‚úÖ V√âRIFICATION DES PERMISSIONS
    if (userId && video.user_id !== userId) {
      throw new Error('Acc√®s non autoris√© √† cette vid√©o');
    }

    console.log("‚úÖ Vid√©o trouv√©e, mise √† jour statut ANALYZING");

    // ‚úÖ MISE √Ä JOUR DU STATUT
    const { error: updateError } = await retryWithBackoff(async () => {
      return await supabase
        .from('videos')
        .update({ 
          status: VIDEO_STATUS.ANALYZING,
          updated_at: new Date().toISOString()
        })
        .eq('id', videoId);
    });

    if (updateError) {
      throw new Error(`Erreur mise √† jour statut: ${updateError.message}`);
    }

    // ‚úÖ R√âCUP√âRATION DU TEXTE √Ä ANALYSER
    let textToAnalyze = cleanTranscriptionText;
    
    if (!textToAnalyze || textToAnalyze.trim().length === 0) {
      console.log("üìÑ Fetch transcription depuis DB...");
      textToAnalyze = video?.transcription_text || 
                     video?.transcription_data?.text || 
                     video?.transcript?.text || 
                     '';
      
      console.log(`üìÑ Texte r√©cup√©r√© depuis DB: ${textToAnalyze?.length || 0} caract√®res`);
    }

    if (!textToAnalyze || textToAnalyze.trim().length === 0) {
      console.warn("‚ö†Ô∏è Aucun texte de transcription disponible, cr√©ation d'analyse basique");
      textToAnalyze = "Cette vid√©o ne contient pas de transcription analysable.";
    }

    // ‚úÖ V√âRIFICATION DU CACHE
    const textHash = generateTextHash(textToAnalyze);
    const cacheKey = `${videoId}_${textHash}`;
    
    const cachedAnalysis = analysisCache.get(cacheKey);
    if (cachedAnalysis && (Date.now() - cachedAnalysis.timestamp < CACHE_TTL)) {
      console.log("‚úÖ Utilisation de l'analyse en cache");
      
      await updateVideoWithAnalysis(supabase, videoId, cachedAnalysis.analysis);
      
      return new Response(
        JSON.stringify({ 
          success: true, 
          message: 'Analyse multilingue termin√©e avec succ√®s (cache)',
          videoId: videoId,
          aiScore: cachedAnalysis.analysis.ai_score,
          fromCache: true
        }),
        { 
          status: 200, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    console.log(`üîç D√©but analyse pour video ${videoId}, longueur texte: ${textToAnalyze.length}`);

    // ‚úÖ D√âTECTION AUTOMATIQUE DE LA LANGUE
    let analysisLanguage = transcriptionLanguage || video?.transcription_language || 'fr';
    
    if (!analysisLanguage || analysisLanguage === 'auto') {
      console.log("üîç D√©tection automatique de la langue...");
      analysisLanguage = detectLanguageAdvanced(textToAnalyze);
      console.log(`üåê Langue d√©tect√©e: ${analysisLanguage}`);
    }

    const languageScores = calculateAllLanguageScores(textToAnalyze);
    analysisLanguage = determineBestLanguage(languageScores, analysisLanguage);

    if (!SUPPORTED_ANALYSIS_LANGUAGES[analysisLanguage]) {
      console.warn(`‚ö†Ô∏è Langue ${analysisLanguage} non support√©e, utilisation du fran√ßais par d√©faut`);
      analysisLanguage = 'fr';
    }

    const systemMessage = SYSTEM_MESSAGES[analysisLanguage] || SYSTEM_MESSAGES['fr'];
    const analysisPromptTemplate = ANALYSIS_PROMPTS[analysisLanguage] || ANALYSIS_PROMPTS['fr'];
    
    const textForAnalysis = optimizeTextForAnalysis(textToAnalyze, 6000);
    const analysisPrompt = analysisPromptTemplate.replace('{text}', textForAnalysis);

    console.log(`ü§ñ Appel OpenAI en ${analysisLanguage}...`);
    
    let completion;
    try {
      completion = await retryWithBackoff(async () => {
        return await openai.chat.completions.create({
          model: "gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: systemMessage
            },
            {
              role: "user",
              content: analysisPrompt
            }
          ],
          max_tokens: 2500, // Augment√© pour l'analyse de tonalit√©
          temperature: 0.3,
          response_format: { type: "json_object" }
        });
      });
    } catch (openaiError) {
      console.error("‚ùå Erreur OpenAI apr√®s retry:", openaiError);
      throw new Error(`Erreur analyse OpenAI: ${openaiError.message}`);
    }

    console.log("‚úÖ R√©ponse OpenAI re√ßue");

    const analysisText = completion.choices[0].message.content;
    console.log("üìÑ R√©ponse OpenAI:", analysisText?.substring(0, 300) + "...");

    let analysisResult;
    try {
      if (!analysisText || analysisText.trim().length === 0) {
        throw new Error('R√©ponse OpenAI vide');
      }
      
      analysisResult = JSON.parse(analysisText);
      console.log("‚úÖ Analyse JSON pars√©e avec succ√®s");
    } catch (parseError) {
      console.error("‚ùå Erreur parsing JSON OpenAI, utilisation fallback:", parseError);
      analysisResult = createEnhancedAnalysis(textToAnalyze, analysisLanguage);
    }

    // ‚úÖ ENRICHIR LES R√âSULTATS AVEC ANALYSE DE TONALIT√â
    analysisResult.analysis_language = analysisLanguage;
    analysisResult.analysis_language_name = SUPPORTED_ANALYSIS_LANGUAGES[analysisLanguage] || 'Unknown';
    analysisResult.analyzed_at = new Date().toISOString();
    analysisResult.text_length = textToAnalyze.length;
    analysisResult.model_used = "gpt-3.5-turbo";

    // ‚úÖ CORRECTION : Calcul du score IA am√©lior√© avec tonalit√©
    const aiScore = calculateEnhancedAIScore(analysisResult, textToAnalyze);
    analysisResult.ai_score = aiScore;
    console.log(`üìä Score IA calcul√©: ${aiScore}`);

    console.log("üîç Extraction des insights de matching...");
    const matchingInsights = await extractAdvancedMatchingInsights(analysisResult, textToAnalyze, analysisLanguage);
    console.log("‚úÖ Insights de matching extraits");

    await saveAnalysisResults(supabase, videoId, analysisResult, matchingInsights, aiScore);

    analysisCache.set(cacheKey, {
      analysis: analysisResult,
      timestamp: Date.now()
    });

    console.log("üéâ Analyse multilingue avec tonalit√© termin√©e avec succ√®s");

    return new Response(
      JSON.stringify({ 
        success: true, 
        message: 'Analyse multilingue avec tonalit√© termin√©e avec succ√®s',
        videoId: videoId,
        aiScore: aiScore,
        matchingInsights: matchingInsights,
        analysisLanguage: analysisLanguage,
        analysisLanguageName: SUPPORTED_ANALYSIS_LANGUAGES[analysisLanguage] || 'Unknown',
        textLength: textToAnalyze.length,
        fromCache: false
      }),
      { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );

  } catch (error) {
    console.error("üí• Erreur g√©n√©rale dans analyze-transcription:", error);

    if (videoId) {
      try {
        const supabaseUrl = Deno.env.get('SUPABASE_URL');
        const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
        
        if (supabaseUrl && supabaseServiceKey) {
          const supabase = createClient(supabaseUrl, supabaseServiceKey);
          await supabase
            .from('videos')
            .update({ 
              status: VIDEO_STATUS.FAILED,
              error_message: error.message.substring(0, 500),
              updated_at: new Date().toISOString()
            })
            .eq('id', videoId);
          console.log("üìù Statut erreur sauvegard√©");
        }
      } catch (updateError) {
        console.error("‚ùå Erreur sauvegarde statut erreur:", updateError);
      }
    }

    return new Response(
      JSON.stringify({ 
        error: 'Erreur lors de l\'analyse multilingue avec tonalit√©', 
        details: error.message,
        videoId: videoId
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );
  }
});

// ‚úÖ FONCTIONS UTILITAIRES AM√âLIOR√âES

function generateTextHash(text) {
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash.toString(36);
}

function detectLanguageAdvanced(text) {
  if (!text || text.trim().length === 0) return 'fr';
  
  const scores = {};
  const words = text.toLowerCase().split(/\s+/).slice(0, 200);
  
  for (const [lang, keywords] of Object.entries(LANGUAGE_DETECTION_KEYWORDS)) {
    let score = 0;
    const uniqueKeywords = [...new Set(keywords)];
    for (const keyword of uniqueKeywords) {
      if (words.includes(keyword.toLowerCase())) {
        score++;
      }
      if (text.toLowerCase().includes(keyword.toLowerCase())) {
        score += 0.5;
      }
    }
    scores[lang] = score / uniqueKeywords.length;
  }
  
  let bestLanguage = 'fr';
  let bestScore = 0;
  
  for (const [lang, score] of Object.entries(scores)) {
    if (score > bestScore) {
      bestScore = score;
      bestLanguage = lang;
    }
  }
  
  console.log(`üîç Scores de d√©tection avanc√©e:`, scores);
  console.log(`üéØ Langue s√©lectionn√©e: ${bestLanguage} (score: ${bestScore.toFixed(3)})`);
  
  return bestScore > 0.05 ? bestLanguage : 'fr';
}

function calculateAllLanguageScores(text) {
  const scores = {};
  for (const lang of Object.keys(LANGUAGE_DETECTION_KEYWORDS)) {
    scores[lang] = calculateLanguageScore(text, lang);
  }
  return scores;
}

function calculateLanguageScore(text, language) {
  if (!text || text.trim().length === 0) return 0;
  
  const keywords = LANGUAGE_DETECTION_KEYWORDS[language] || [];
  if (keywords.length === 0) return 0;
  
  const words = text.toLowerCase().split(/\s+/).slice(0, 200);
  let score = 0;
  
  for (const keyword of keywords) {
    if (words.includes(keyword.toLowerCase())) {
      score++;
    }
  }
  
  return score / keywords.length;
}

function determineBestLanguage(scores, currentLanguage) {
  let bestLanguage = currentLanguage;
  let bestScore = scores[currentLanguage] || 0;
  
  for (const [lang, score] of Object.entries(scores)) {
    if (score > bestScore + 0.1) {
      bestScore = score;
      bestLanguage = lang;
    }
  }
  
  return bestLanguage;
}

function optimizeTextForAnalysis(text, maxLength) {
  if (text.length <= maxLength) return text;
  
  const sentences = text.split(/[.!?]+/);
  let optimizedText = '';
  
  for (const sentence of sentences) {
    if ((optimizedText + sentence).length > maxLength) break;
    optimizedText += sentence + '.';
  }
  
  if (optimizedText.length === 0) {
    optimizedText = text.substring(0, maxLength - 100) + "... [texte tronqu√© pour l'analyse]";
  }
  
  return optimizedText;
}

async function updateVideoWithAnalysis(supabase, videoId, analysis) {
  const { error } = await supabase
    .from('videos')
    .update({
      status: VIDEO_STATUS.ANALYZED,
      analysis: analysis,
      ai_score: analysis.ai_score,
      updated_at: new Date().toISOString()
    })
    .eq('id', videoId);
    
  if (error) throw error;
}

async function saveAnalysisResults(supabase, videoId, analysisResult, matchingInsights, aiScore) {
  const updatePayload = {
    status: VIDEO_STATUS.ANALYZED,
    analysis: analysisResult,
    ai_score: aiScore,
    updated_at: new Date().toISOString()
  };

  try {
    const { error } = await supabase
      .from('videos')
      .update({
        ...updatePayload,
        analysis_language: analysisResult.analysis_language,
        matching_insights: matchingInsights
      })
      .eq('id', videoId);

    if (error) {
      console.warn("‚ö†Ô∏è Colonnes √©tendues non disponibles, mise √† jour basique");
      await supabase
        .from('videos')
        .update(updatePayload)
        .eq('id', videoId);
    }
  } catch (error) {
    console.error("‚ùå Erreur sauvegarde √©tendue, fallback basique:", error);
    await supabase
      .from('videos')
      .update(updatePayload)
      .eq('id', videoId);
  }
}

// ‚úÖ CORRECTION : Fonction createEnhancedAnalysis avec analyse de tonalit√© am√©lior√©e
function createEnhancedAnalysis(text, language = 'fr') {
  const wordCount = text.split(/\s+/).filter(word => word.length > 0).length;
  const sentenceCount = text.split(/[.!?]+/).length - 1;
  
  // Analyse de tonalit√© bas√©e sur le texte
  const hasExclamation = text.includes('!');
  const hasQuestion = text.includes('?');
  const avgSentenceLength = wordCount / Math.max(sentenceCount, 1);
  
  let emotion = "neutre";
  let pace = "mod√©r√©";
  let energy = "moyen";
  
  if (hasExclamation && avgSentenceLength < 10) {
    emotion = "enthousiaste";
    pace = "rapide";
    energy = "√©lev√©";
  } else if (hasQuestion && avgSentenceLength > 15) {
    emotion = "r√©fl√©chi";
    pace = "lent";
    energy = "faible";
  } else if (wordCount < 50) {
    emotion = "calme";
    pace = "lent";
    energy = "faible";
  }
  
  const ENHANCED_ANALYSIS_TEXTS = {
    fr: {
      summary: `Analyse basique: ${wordCount} mots, ${sentenceCount} phrases d√©tect√©es. Le contenu exprime une passion communicatrice.`,
      topics: ["communication", "partage", "expression", "passion"],
      advice: [
        "Continuez √† pratiquer r√©guli√®rement pour am√©liorer votre fluidit√©",
        "Variez le d√©bit pour maintenir l'attention de votre audience",
        "Utilisez des pauses strat√©giques pour renforcer votre message"
      ],
      tone_suggestions: [
        "Le ton est bien √©quilibr√© pour ce type de contenu",
        "Essayez de varier les intonations pour plus d'impact",
        "La clart√© vocale est adapt√©e √† la communication"
      ]
    },
    ar: {
      summary: `ÿ™ÿ≠ŸÑŸäŸÑ ÿ£ÿ≥ÿßÿ≥Ÿä: ${wordCount} ŸÉŸÑŸÖÿ©, ${sentenceCount} ÿ¨ŸÖŸÑÿ© ŸÖŸÉÿ™ÿ¥ŸÅÿ©. ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ Ÿäÿπÿ®ÿ± ÿπŸÜ ÿ¥ÿ∫ŸÅ ÿ™ŸàÿßÿµŸÑŸä.`,
      topics: ["ÿßÿ™ÿµÿßŸÑ", "ŸÖÿ¥ÿßÿ±ŸÉÿ©", "ÿ™ÿπÿ®Ÿäÿ±", "ÿ¥ÿ∫ŸÅ"],
      advice: [
        "ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑŸÖŸÖÿßÿ±ÿ≥ÿ© ÿ®ÿßŸÜÿ™ÿ∏ÿßŸÖ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿ∑ŸÑÿßŸÇÿ™ŸÉ",
        "ÿ∫Ÿäÿ± ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ≠ÿØŸäÿ´ ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÜÿ™ÿ®ÿßŸá ÿ¨ŸÖŸáŸàÿ±ŸÉ",
        "ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸàŸÇŸÅÿßÿ™ ÿßŸÑÿ•ÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ© ŸÑÿ™ÿπÿ≤Ÿäÿ≤ ÿ±ÿ≥ÿßŸÑÿ™ŸÉ"
      ],
      tone_suggestions: [
        "ÿßŸÑŸÜÿ®ÿ±ÿ© ŸÖÿ™Ÿàÿßÿ≤ŸÜÿ© ÿ®ÿ¥ŸÉŸÑ ÿ¨ŸäÿØ ŸÑŸáÿ∞ÿß ÿßŸÑŸÜŸàÿπ ŸÖŸÜ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ",
        "ÿ≠ÿßŸàŸÑ ÿ™ŸÜŸàŸäÿπ ÿßŸÑÿ™ŸÜÿ∫ŸäŸÖ ŸÑŸÖÿ≤ŸäÿØ ŸÖŸÜ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±",
        "Ÿàÿ∂Ÿàÿ≠ ÿßŸÑÿµŸàÿ™ ŸÖŸÜÿßÿ≥ÿ® ŸÑŸÑÿ™ŸàÿßÿµŸÑ"
      ]
    },
    en: {
      summary: `Basic analysis: ${wordCount} words, ${sentenceCount} sentences detected. The content expresses communicative passion.`,
      topics: ["communication", "sharing", "expression", "passion"],
      advice: [
        "Continue practicing regularly to improve your fluency",
        "Vary your pace to maintain your audience's attention", 
        "Use strategic pauses to strengthen your message"
      ],
      tone_suggestions: [
        "The tone is well balanced for this type of content",
        "Try varying intonations for more impact",
        "Vocal clarity is suitable for communication"
      ]
    }
  };

  const texts = ENHANCED_ANALYSIS_TEXTS[language] || ENHANCED_ANALYSIS_TEXTS.fr;

  return {
    summary: texts.summary,
    key_topics: texts.topics,
    sentiment: "positif",
    sentiment_score: 0.6,
    communication_advice: texts.advice,
    tone_analysis: {
      emotion: emotion,
      pace: pace,
      clarity: "bonne",
      energy: energy,
      confidence_level: 0.7,
      cultural_insights: ["Expression authentique", "Communication engageante"],
      tone_suggestions: texts.tone_suggestions
    },
    structure_analysis: {
      introduction: "bon",
      development: "bon",
      conclusion: "bon",
      overall_structure: "bon"
    },
    target_audience: ["Communaut√© France-Maroc", "Passionn√©s de communication"],
    visual_suggestions: ["Utilisez un arri√®re-plan neutre", "Maintenez un contact visuel r√©gulier"],
    analysis_language: language
  };
}

// ‚úÖ CORRECTION : Calcul du score IA am√©lior√© avec pond√©ration pour la tonalit√©
function calculateEnhancedAIScore(analysisResult, originalText) {
  let score = 6.0;
  
  // Pond√©ration pour le contenu principal
  if (analysisResult.summary && analysisResult.summary.length > 50) score += 0.5;
  if (analysisResult.key_topics && analysisResult.key_topics.length >= 3) score += 0.5;
  if (analysisResult.communication_advice && analysisResult.communication_advice.length >= 2) score += 0.5;
  if (analysisResult.sentiment_score > 0.7) score += 0.5;
  
  // Pond√©ration pour l'analyse de tonalit√© (nouveau - 40% du score)
  if (analysisResult.tone_analysis) {
    score += 0.5; // Base pour avoir une analyse de tonalit√©
    
    if (analysisResult.tone_analysis.emotion && analysisResult.tone_analysis.emotion !== "neutre") score += 0.3;
    if (analysisResult.tone_analysis.tone_suggestions && analysisResult.tone_analysis.tone_suggestions.length >= 2) score += 0.3;
    if (analysisResult.tone_analysis.confidence_level > 0.7) score += 0.3;
    if (analysisResult.tone_analysis.cultural_insights && analysisResult.tone_analysis.cultural_insights.length > 0) score += 0.3;
  }
  
  if (analysisResult.structure_analysis) score += 0.5;
  
  if (analysisResult.cultural_insights && analysisResult.cultural_insights.length > 0) score += 0.3;
  if (analysisResult.target_audience && analysisResult.target_audience.length > 0) score += 0.3;
  
  // P√©nalit√© pour texte trop court
  if (originalText.length < 100) score -= 1.0;
  
  return Math.min(Math.max(score, 0), 10.0);
}

async function extractAdvancedMatchingInsights(analysis, transcription, language = 'fr') {
  const LEARNING_STYLES = {
    fr: { pratique: 'pratique', r√©flexif: 'r√©flexif', √©quilibr√©: '√©quilibr√©' },
    ar: { pratique: 'ÿπŸÖŸÑŸä', r√©flexif: 'ÿ™ÿ£ŸÖŸÑŸä', √©quilibr√©: 'ŸÖÿ™Ÿàÿßÿ≤ŸÜ' },
    en: { pratique: 'practical', r√©flexif: 'reflective', √©quilibr√©: 'balanced' }
  };

  const learningStyleMap = LEARNING_STYLES[language] || LEARNING_STYLES.fr;

  const skills = extractSkillsFromText(transcription);
  const interests = analysis.key_topics || [];
  const communicationStyle = analysis.tone_analysis?.emotion || 'neutre';

  return {
    communication_style: communicationStyle,
    expertise_areas: interests,
    detected_skills: skills,
    sentiment_profile: analysis.sentiment,
    key_strengths: analysis.communication_advice || [],
    tone_profile: {
      emotion: analysis.tone_analysis?.emotion,
      pace: analysis.tone_analysis?.pace,
      energy: analysis.tone_analysis?.energy,
      clarity: analysis.tone_analysis?.clarity
    },
    potential_mentor_topics: extractMentorTopics(analysis, transcription),
    learning_preferences: extractLearningStyle(analysis, language, learningStyleMap),
    compatibility_factors: {
      cultural_affinity: detectCulturalAffinity(transcription),
      communication_flow: analyzeCommunicationFlow(analysis),
      expertise_match: calculateExpertiseMatch(interests),
      tone_compatibility: analyzeToneCompatibility(analysis.tone_analysis)
    },
    analysis_language: language,
    analysis_timestamp: new Date().toISOString()
  };
}

function extractSkillsFromText(text) {
  const skillsKeywords = {
    'leadership': ['leader', 'diriger', '√©quipe', 'manager', 'coach'],
    'communication': ['communiquer', 'parler', 'exprimer', 'discuter', 'pr√©senter'],
    'technique': ['technique', 'comp√©tence', 'ma√Ætriser', 'expert', 'sp√©cialiste'],
    'cr√©ativit√©': ['cr√©atif', 'innover', 'imagination', 'original', 'cr√©ation']
  };
  
  const detectedSkills = [];
  const lowerText = text.toLowerCase();
  
  for (const [skill, keywords] of Object.entries(skillsKeywords)) {
    if (keywords.some(keyword => lowerText.includes(keyword))) {
      detectedSkills.push(skill);
    }
  }
  
  return detectedSkills;
}

function extractMentorTopics(analysis, transcription) {
  const topics = analysis.key_topics || [];
  return topics.filter(topic => 
    transcription.toLowerCase().includes(topic.toLowerCase()) &&
    topic.length > 4
  ).slice(0, 4);
}

function extractLearningStyle(analysis, language = 'fr', styleMap = null) {
  if (!styleMap) {
    styleMap = { pratique: 'pratique', r√©flexif: 'r√©flexif', √©quilibr√©: '√©quilibr√©' };
  }

  const pace = analysis.tone_analysis?.pace;
  const fastKeywords = ['rapide', 'fast', 'r√°pido', 'schnell', 'veloce', 'ÿ≥ÿ±Ÿäÿπ'];
  const slowKeywords = ['lent', 'slow', 'lento', 'langsam', 'lento', 'ÿ®ÿ∑Ÿäÿ°'];
  
  if (fastKeywords.some(keyword => pace?.toLowerCase().includes(keyword))) {
    return styleMap.pratique;
  }
  if (slowKeywords.some(keyword => pace?.toLowerCase().includes(keyword))) {
    return styleMap.r√©flexif;
  }
  return styleMap.√©quilibr√©;
}

function detectCulturalAffinity(text) {
  const culturalKeywords = {
    'france': ['france', 'fran√ßais', 'paris', 'lyon', 'marseille'],
    'maroc': ['maroc', 'marocain', 'casablanca', 'rabat', 'marrakech'],
    'intercultural': ['culture', 'tradition', '√©change', 'interculturel']
  };
  
  const lowerText = text.toLowerCase();
  const affinities = [];
  
  for (const [culture, keywords] of Object.entries(culturalKeywords)) {
    if (keywords.some(keyword => lowerText.includes(keyword))) {
      affinities.push(culture);
    }
  }
  
  return affinities.length > 0 ? affinities : ['intercultural'];
}

function analyzeCommunicationFlow(analysis) {
  const clarity = analysis.tone_analysis?.clarity;
  const pace = analysis.tone_analysis?.pace;
  
  if (clarity === 'excellente' && pace === 'mod√©r√©') return 'optimal';
  if (clarity === 'bonne' && pace === 'mod√©r√©') return 'bon';
  return 'standard';
}

function analyzeToneCompatibility(toneAnalysis) {
  if (!toneAnalysis) return 'standard';
  
  const { emotion, pace, energy, clarity } = toneAnalysis;
  
  if (emotion === 'enthousiaste' && pace === 'mod√©r√©' && energy === '√©lev√©' && clarity === 'bonne') {
    return 'excellent';
  }
  if (emotion === 'confiant' && pace === 'mod√©r√©' && clarity === 'bonne') {
    return 'tr√®s bon';
  }
  
  return 'bon';
}

function calculateExpertiseMatch(interests) {
  return interests.length >= 3 ? '√©lev√©' : 
         interests.length >= 2 ? 'moyen' : 'faible';
}
