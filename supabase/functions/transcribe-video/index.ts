// supabase/functions/transcribe-video/index.ts
import { createClient } from 'npm:@supabase/supabase-js@2.39.3'
import OpenAI from 'npm:openai@4.28.0'

const VIDEO_STATUS = { 
  UPLOADED: 'uploaded', 
  PROCESSING: 'processing', 
  TRANSCRIBED: 'transcribed', 
  ANALYZING: 'analyzing', 
  ANALYZED: 'analyzed', 
  PUBLISHED: 'published', 
  FAILED: 'failed' 
}

const corsHeaders = { 
  'Access-Control-Allow-Origin': '*', 
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type', 
  'Access-Control-Allow-Methods': 'POST, OPTIONS' 
}

// ‚úÖ SUPPORT MULTILINGUE √âTENDU - CORRIG√â
const SUPPORTED_LANGUAGES = {
  'fr': { name: 'French', whisperCode: 'fr' },
  'en': { name: 'English', whisperCode: 'en' },
  'es': { name: 'Spanish', whisperCode: 'es' },
  'de': { name: 'German', whisperCode: 'de' },
  'it': { name: 'Italian', whisperCode: 'it' },
  'pt': { name: 'Portuguese', whisperCode: 'pt' },
  'ru': { name: 'Russian', whisperCode: 'ru' },
  'zh': { name: 'Chinese', whisperCode: 'zh' },
  'ja': { name: 'Japanese', whisperCode: 'ja' },
  'ar': { name: 'Arabic', whisperCode: 'ar' }
};

// ‚úÖ WHISPER LANGUAGE MAPPING CORRECT
const WHISPER_LANGUAGE_MAPPING = {
  'fr': 'french',
  'en': 'english', 
  'es': 'spanish',
  'de': 'german',
  'it': 'italian',
  'pt': 'portuguese',
  'ru': 'russian',
  'zh': 'chinese',
  'ja': 'japanese',
  'ar': 'arabic'
};

Deno.serve(async (req) => {
  console.log("üé§ transcribe-video (multilingue corrig√©e) appel√©e");

  // ‚úÖ GESTION CORS CORRECTE
  if (req.method === 'OPTIONS') {
    return new Response('ok', { 
      headers: {
        ...corsHeaders,
        'Access-Control-Max-Age': '86400',
      }
    });
  }

  // ‚úÖ V√âRIFICATION M√âTHODE POST
  if (req.method !== 'POST') {
    return new Response(
      JSON.stringify({ error: 'M√©thode non autoris√©e' }),
      { 
        status: 405, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    );
  }

  let videoId = null;

  try {
    console.log("üì® Headers:", Object.fromEntries(req.headers));
    
    // ‚úÖ CORRECTION CRITIQUE: Gestion ROBUSTE du parsing JSON
    let requestBody;
    let rawBody = '';
    
    try {
      rawBody = await req.text();
      console.log("üì¶ Corps brut re√ßu (premiers 500 caract√®res):", rawBody.substring(0, 500));
      
      if (!rawBody || rawBody.trim().length === 0) {
        throw new Error('Corps de requ√™te vide');
      }
      
      requestBody = JSON.parse(rawBody);
      console.log("‚úÖ JSON pars√© avec succ√®s:", { 
        videoId: requestBody.videoId,
        userId: requestBody.userId,
        hasVideoUrl: !!requestBody.videoUrl 
      });
    } catch (parseError) {
      console.error("‚ùå Erreur parsing JSON:", parseError);
      return new Response(
        JSON.stringify({ 
          error: 'Corps de requ√™te JSON invalide',
          details: parseError.message,
          bodyPreview: rawBody.substring(0, 200)
        }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    const { videoId: vidId, userId, videoUrl, preferredLanguage, autoDetectLanguage = true } = requestBody;
    videoId = vidId;

    // ‚úÖ VALIDATION AM√âLIOR√âE
    if (!videoId || !userId || !videoUrl) {
      return new Response(
        JSON.stringify({ 
          error: 'Param√®tres manquants: videoId, userId, videoUrl requis',
          received: { 
            videoId: videoId, 
            userId: userId, 
            videoUrl: videoUrl ? 'pr√©sent' : 'manquant' 
          }
        }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    // ‚úÖ VALIDATION URL CORRECTE
    try {
      new URL(videoUrl);
    } catch (urlError) {
      return new Response(
        JSON.stringify({ error: `URL vid√©o invalide: ${videoUrl}. Erreur: ${urlError.message}` }),
        { 
          status: 400, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    // ‚úÖ R√âCUP√âRATION S√âCURIS√âE DES CL√âS
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    const openaiApiKey = Deno.env.get('OPENAI_API_KEY');

    if (!supabaseUrl || !supabaseServiceKey) {
      console.error('‚ùå Configuration Supabase manquante');
      return new Response(
        JSON.stringify({ error: 'Configuration Supabase manquante' }),
        { 
          status: 500, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    if (!openaiApiKey) {
      console.error('‚ùå Cl√© API OpenAI manquante');
      return new Response(
        JSON.stringify({ error: 'Cl√© API OpenAI manquante' }),
        { 
          status: 500, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);
    const openai = new OpenAI({ apiKey: openaiApiKey });

    // ‚úÖ V√âRIFICATION QUE LA VID√âO EXISTE ET APPARTIENT √Ä L'UTILISATEUR
    console.log("üîç V√©rification vid√©o:", videoId);
    const { data: video, error: videoError } = await supabase
      .from('videos')
      .select('*')
      .eq('id', videoId)
      .single();

    if (videoError || !video) {
      console.error('‚ùå Vid√©o non trouv√©e:', videoError);
      return new Response(
        JSON.stringify({ error: 'Vid√©o non trouv√©e ou acc√®s non autoris√©' }),
        { 
          status: 404, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    // ‚úÖ V√âRIFICATION DES PERMISSIONS
    if (video.user_id !== userId) {
      console.error('‚ùå Acc√®s non autoris√©:', { videoUserId: video.user_id, requestUserId: userId });
      return new Response(
        JSON.stringify({ error: 'Acc√®s non autoris√© √† cette vid√©o' }),
        { 
          status: 403, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    console.log("üîÑ Mise √† jour statut PROCESSING");

    // ‚úÖ MISE √Ä JOUR STATUT - GESTION DE FALLBACK
    let statusUpdatePayload: any = {
      status: VIDEO_STATUS.PROCESSING,
      updated_at: new Date().toISOString()
    };

    try {
      // Essayer avec transcription_language
      const { error: updateError } = await supabase
        .from('videos')
        .update({
          ...statusUpdatePayload,
          transcription_language: preferredLanguage || 'auto'
        })
        .eq('id', videoId);

      if (updateError) {
        console.warn("‚ö†Ô∏è Colonne transcription_language non disponible, mise √† jour sans...");
        // R√©essayer sans la colonne
        const { error: fallbackError } = await supabase
          .from('videos')
          .update(statusUpdatePayload)
          .eq('id', videoId);
        
        if (fallbackError) throw fallbackError;
      }
    } catch (updateError) {
      console.error("‚ùå Erreur mise √† jour statut:", updateError);
      return new Response(
        JSON.stringify({ error: `Erreur mise √† jour statut: ${updateError.message}` }),
        { 
          status: 500, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    console.log('üéôÔ∏è D√©but transcription multilingue pour la vid√©o:', videoId);
    console.log("üåê Param√®tres langue:", { preferredLanguage, autoDetectLanguage });

    // ‚úÖ T√âL√âCHARGEMENT S√âCURIS√â AVEC TIMEOUT
    console.log("üì• T√©l√©chargement vid√©o...");
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 45000); // 45s timeout
    
    let videoResponse;
    try {
      videoResponse = await fetch(videoUrl, {
        signal: controller.signal,
        headers: {
          'User-Agent': 'SpotBulle-Multilingual-Transcription/2.0',
          'Range': 'bytes=0-10485760' // Limiter √† 10MB pour la transcription
        }
      });
      clearTimeout(timeoutId);
    } catch (fetchError) {
      clearTimeout(timeoutId);
      if (fetchError.name === 'AbortError') {
        throw new Error('Timeout lors du t√©l√©chargement de la vid√©o');
      }
      throw new Error(`Erreur r√©seau: ${fetchError.message}`);
    }
    
    if (!videoResponse.ok) {
      const errorText = await videoResponse.text().catch(() => 'Impossible de lire la r√©ponse');
      throw new Error(`Erreur t√©l√©chargement vid√©o: ${videoResponse.status} ${videoResponse.statusText}`);
    }

    const videoBlob = await videoResponse.blob();
    console.log(`üìä Taille vid√©o t√©l√©charg√©e: ${videoBlob.size} bytes`);

    if (videoBlob.size === 0) {
      throw new Error('Fichier vid√©o vide ou inaccessible');
    }

    if (videoBlob.size > 25 * 1024 * 1024) {
      throw new Error('Fichier vid√©o trop volumineux pour la transcription (>25MB)');
    }

    // ‚úÖ CONFIGURATION WHISPER CORRECTE
    const whisperConfig: any = {
      file: new File([videoBlob], `video-${videoId}.mp4`, { 
        type: 'video/mp4' 
      }),
      model: 'whisper-1',
      response_format: 'verbose_json',
      temperature: 0.0,
    };

    // ‚úÖ GESTION LANGUE CORRECTE
    if (preferredLanguage && WHISPER_LANGUAGE_MAPPING[preferredLanguage]) {
      whisperConfig.language = WHISPER_LANGUAGE_MAPPING[preferredLanguage];
      console.log(`üéØ Transcription en langue sp√©cifi√©e: ${SUPPORTED_LANGUAGES[preferredLanguage]?.name}`);
    } else if (!autoDetectLanguage) {
      whisperConfig.language = 'french';
      console.log("üîç D√©tection auto d√©sactiv√©e, utilisation du fran√ßais par d√©faut");
    } else {
      console.log("üåê D√©tection automatique de la langue activ√©e");
    }

    // ‚úÖ TRANSCRIPTION AVEC GESTION D'ERREUR
    console.log("ü§ñ Appel Whisper multilingue...");
    let transcriptionResponse;
    try {
      transcriptionResponse = await openai.audio.transcriptions.create(whisperConfig);
    } catch (openaiError) {
      console.error('‚ùå Erreur OpenAI Whisper:', openaiError);
      
      // Tentative de fallback sans langue sp√©cifi√©e
      if (whisperConfig.language) {
        console.log("üîÑ Tentative de fallback sans langue sp√©cifi√©e...");
        delete whisperConfig.language;
        transcriptionResponse = await openai.audio.transcriptions.create(whisperConfig);
      } else {
        throw new Error(`Erreur transcription OpenAI: ${openaiError.message}`);
      }
    }

    const transcriptionText = transcriptionResponse.text?.trim();
    const detectedLanguage = transcriptionResponse.language || preferredLanguage || 'fr';
    
    // ‚úÖ VALIDATION TRANSCRIPTION
    if (!transcriptionText || transcriptionText.length === 0) {
      throw new Error('La transcription est vide - aucun texte d√©tect√© dans la vid√©o');
    }

    console.log(`‚úÖ Transcription r√©ussie - Langue: ${detectedLanguage}, Longueur: ${transcriptionText.length}`);

    // ‚úÖ PR√âPARATION DONN√âES TRANSCRIPTION
    const transcriptionData = {
      text: transcriptionText,
      language: detectedLanguage,
      language_name: SUPPORTED_LANGUAGES[detectedLanguage]?.name || 'Unknown',
      duration: transcriptionResponse.duration,
      words: transcriptionResponse.words || [],
      segments: transcriptionResponse.segments || [],
      confidence: transcriptionResponse.confidence || calculateConfidence(transcriptionText),
      detected_automatically: !preferredLanguage && autoDetectLanguage,
      model: 'whisper-1',
      processed_at: new Date().toISOString()
    };

    // ‚úÖ SAUVEGARDE R√âSULTATS AVEC FALLBACK
    console.log("üíæ Sauvegarde transcription multilingue...");
    const updatePayload: any = {
      status: VIDEO_STATUS.TRANSCRIBED,
      transcription_text: transcriptionText,
      transcription_data: transcriptionData,
      updated_at: new Date().toISOString()
    };

    try {
      const { error } = await supabase
        .from('videos')
        .update({
          ...updatePayload,
          transcription_language: detectedLanguage
        })
        .eq('id', videoId);

      if (error) {
        console.warn("‚ö†Ô∏è Colonne transcription_language non disponible, sauvegarde sans...");
        await supabase
          .from('videos')
          .update(updatePayload)
          .eq('id', videoId);
      }
    } catch (updateError) {
      console.error("‚ùå Erreur sauvegarde transcription:", updateError);
      throw new Error(`Erreur sauvegarde: ${updateError.message}`);
    }

    // ‚úÖ D√âCLENCHEMENT ANALYSE S√âCURIS√â
    console.log("üöÄ D√©clenchement analyse multilingue...");
    try {
      const { data, error } = await supabase.functions.invoke('analyze-transcription', {
        body: {
          videoId,
          transcriptionText: transcriptionText,
          userId,
          transcriptionLanguage: detectedLanguage
        }
      });

      if (error) {
        console.warn('‚ö†Ô∏è Erreur d√©clenchement analyse:', error);
      } else {
        console.log('‚úÖ Analyse multilingue d√©clench√©e avec succ√®s');
      }
    } catch (analyzeError) {
      console.warn('‚ö†Ô∏è Erreur lors du d√©clenchement de l\'analyse:', analyzeError);
    }

    return new Response(
      JSON.stringify({ 
        success: true, 
        message: 'Transcription multilingue termin√©e avec succ√®s',
        transcriptionLength: transcriptionText.length,
        language: detectedLanguage,
        languageName: SUPPORTED_LANGUAGES[detectedLanguage]?.name || 'Inconnue',
        confidence: transcriptionData.confidence
      }),
      { 
        status: 200, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )

  } catch (error) {
    console.error('‚ùå Erreur transcription multilingue:', error);

    // ‚úÖ SAUVEGARDE ERREUR
    if (videoId) {
      try {
        const supabaseUrl = Deno.env.get('SUPABASE_URL');
        const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
        
        if (supabaseUrl && supabaseServiceKey) {
          const supabase = createClient(supabaseUrl, supabaseServiceKey);
          await supabase
            .from('videos')
            .update({ 
              status: VIDEO_STATUS.FAILED,
              error_message: error.message.substring(0, 500),
              updated_at: new Date().toISOString()
            })
            .eq('id', videoId);
          console.log("üìù Statut erreur sauvegard√©");
        }
      } catch (updateError) {
        console.error('‚ùå Erreur mise √† jour statut erreur:', updateError);
      }
    }

    return new Response(
      JSON.stringify({ 
        error: 'Erreur lors de la transcription multilingue', 
        details: error.message,
        videoId: videoId
      }),
      { 
        status: 500, 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
      }
    )
  }
})

// ‚úÖ FONCTION UTILITAIRE POUR CALCULER LA CONFIANCE
function calculateConfidence(text: string): number {
  if (!text || text.length === 0) return 0;
  
  let confidence = 0.5;
  
  if (text.length > 100) confidence += 0.2;
  if (text.length > 500) confidence += 0.1;
  
  const sentenceCount = (text.match(/[.!?]+/g) || []).length;
  if (sentenceCount > 3) confidence += 0.1;
  
  const words = text.split(/\s+/).filter(word => word.length > 0);
  const uniqueWords = new Set(words.map(word => word.toLowerCase()));
  const diversity = uniqueWords.size / words.length;
  confidence += diversity * 0.1;
  
  return Math.min(Math.max(confidence, 0.1), 0.95);
}
